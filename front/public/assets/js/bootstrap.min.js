!(function (a, b) {
    'object' == typeof exports && 'undefined' != typeof module
        ? (module.exports = b(require('@popperjs/core')))
        : 'function' == typeof define && define.amd
        ? define(['@popperjs/core'], b)
        : ((a =
              'undefined' != typeof globalThis
                  ? globalThis
                  : a || self).bootstrap = b(a.Popper))
})(this, function (p) {
    'use strict'
    var q = (function (a) {
        if (a && a.__esModule) return a
        var b = Object.create(null)
        return (
            a &&
                Object.keys(a).forEach(function (c) {
                    if ('default' !== c) {
                        var d = Object.getOwnPropertyDescriptor(a, c)
                        Object.defineProperty(
                            b,
                            c,
                            d.get
                                ? d
                                : {
                                      enumerable: !0,
                                      get: function () {
                                          return a[c]
                                      },
                                  },
                        )
                    }
                }),
            (b.default = a),
            Object.freeze(b)
        )
    })(p)
    let r = {
            find: (a, b = document.documentElement) =>
                [].concat(...Element.prototype.querySelectorAll.call(b, a)),
            findOne: (a, b = document.documentElement) =>
                Element.prototype.querySelector.call(b, a),
            children: (a, b) =>
                [].concat(...a.children).filter(a => a.matches(b)),
            parents(c, d) {
                let b = [],
                    a = c.parentNode
                for (
                    ;
                    a && a.nodeType === Node.ELEMENT_NODE && 3 !== a.nodeType;

                )
                    a.matches(d) && b.push(a), (a = a.parentNode)
                return b
            },
            prev(b, c) {
                let a = b.previousElementSibling
                for (; a; ) {
                    if (a.matches(c)) return [a]
                    a = a.previousElementSibling
                }
                return []
            },
            next(b, c) {
                let a = b.nextElementSibling
                for (; a; ) {
                    if (a.matches(c)) return [a]
                    a = a.nextElementSibling
                }
                return []
            },
        },
        s = a => {
            do a += Math.floor(1e6 * Math.random())
            while (document.getElementById(a))
            return a
        },
        t = c => {
            let b = c.getAttribute('data-bs-target')
            if (!b || '#' === b) {
                let a = c.getAttribute('href')
                if (!a || (!a.includes('#') && !a.startsWith('.'))) return null
                a.includes('#') &&
                    !a.startsWith('#') &&
                    (a = '#' + a.split('#')[1]),
                    (b = a && '#' !== a ? a.trim() : null)
            }
            return b
        },
        u = b => {
            let a = t(b)
            return a && document.querySelector(a) ? a : null
        },
        v = b => {
            let a = t(b)
            return a ? document.querySelector(a) : null
        },
        w = c => {
            if (!c) return 0
            let {
                    transitionDuration: a,
                    transitionDelay: b,
                } = window.getComputedStyle(c),
                d = Number.parseFloat(a),
                e = Number.parseFloat(b)
            return d || e
                ? ((a = a.split(',')[0]),
                  (b = b.split(',')[0]),
                  1e3 * (Number.parseFloat(a) + Number.parseFloat(b)))
                : 0
        },
        x = a => {
            a.dispatchEvent(new Event('transitionend'))
        },
        y = a =>
            !(!a || 'object' != typeof a) &&
            (void 0 !== a.jquery && (a = a[0]), void 0 !== a.nodeType),
        z = a =>
            y(a)
                ? a.jquery
                    ? a[0]
                    : a
                : 'string' == typeof a && a.length > 0
                ? r.findOne(a)
                : null,
        A = (a, b) => {
            let c = !1
            a.addEventListener('transitionend', function b() {
                ;(c = !0), a.removeEventListener('transitionend', b)
            }),
                setTimeout(() => {
                    c || x(a)
                }, b + 5)
        },
        B = (b, c, a) => {
            Object.keys(a).forEach(d => {
                var e
                let g = a[d],
                    f = c[d],
                    h =
                        f && y(f)
                            ? 'element'
                            : null == (e = f)
                            ? '' + e
                            : {}.toString
                                  .call(e)
                                  .match(/\s([a-z]+)/i)[1]
                                  .toLowerCase()
                if (!new RegExp(g).test(h))
                    throw new TypeError(
                        `${b.toUpperCase()}: Option "${d}" provided type "${h}" but expected type "${g}".`,
                    )
            })
        },
        C = a => {
            if (!a) return !1
            if (a.style && a.parentNode && a.parentNode.style) {
                let b = getComputedStyle(a),
                    c = getComputedStyle(a.parentNode)
                return (
                    'none' !== b.display &&
                    'none' !== c.display &&
                    'hidden' !== b.visibility
                )
            }
            return !1
        },
        D = a =>
            !a ||
            a.nodeType !== Node.ELEMENT_NODE ||
            !!a.classList.contains('disabled') ||
            (void 0 !== a.disabled
                ? a.disabled
                : a.hasAttribute('disabled') &&
                  'false' !== a.getAttribute('disabled')),
        E = a => {
            if (!document.documentElement.attachShadow) return null
            if ('function' == typeof a.getRootNode) {
                let b = a.getRootNode()
                return b instanceof ShadowRoot ? b : null
            }
            return a instanceof ShadowRoot
                ? a
                : a.parentNode
                ? E(a.parentNode)
                : null
        },
        _ = () => {},
        F = a => a.offsetHeight,
        G = () => {
            let { jQuery: a } = window
            return a && !document.body.hasAttribute('data-bs-no-jquery')
                ? a
                : null
        },
        c = () => 'rtl' === document.documentElement.dir,
        a = b => {
            var a
            ;(a = () => {
                let a = G()
                if (a) {
                    let c = b.NAME,
                        d = a.fn[c]
                    ;(a.fn[c] = b.jQueryInterface),
                        (a.fn[c].Constructor = b),
                        (a.fn[c].noConflict = () => (
                            (a.fn[c] = d), b.jQueryInterface
                        ))
                }
            }),
                'loading' === document.readyState
                    ? document.addEventListener('DOMContentLoaded', a)
                    : a()
        },
        H = a => {
            'function' == typeof a && a()
        },
        I = new Map()
    var J = {
        set(b, c, d) {
            I.has(b) || I.set(b, new Map())
            let a = I.get(b)
            a.has(c) || 0 === a.size
                ? a.set(c, d)
                : console.error(
                      `Bootstrap doesn't allow more than one instance per element. Bound instance: ${
                          Array.from(a.keys())[0]
                      }.`,
                  )
        },
        get: (a, b) => (I.has(a) && I.get(a).get(b)) || null,
        remove(a, c) {
            if (!I.has(a)) return
            let b = I.get(a)
            b.delete(c), 0 === b.size && I.delete(a)
        },
    }
    let K = /[^.]*(?=\..*)\.|.*/,
        L = /\..*/,
        M = /::\d+$/,
        N = {},
        O = 1,
        P = { mouseenter: 'mouseover', mouseleave: 'mouseout' },
        Q = /^(mouseenter|mouseleave)/i,
        R = new Set([
            'click',
            'dblclick',
            'mouseup',
            'mousedown',
            'contextmenu',
            'mousewheel',
            'DOMMouseScroll',
            'mouseover',
            'mouseout',
            'mousemove',
            'selectstart',
            'selectend',
            'keydown',
            'keypress',
            'keyup',
            'orientationchange',
            'touchstart',
            'touchmove',
            'touchend',
            'touchcancel',
            'pointerdown',
            'pointermove',
            'pointerup',
            'pointerleave',
            'pointercancel',
            'gesturestart',
            'gesturechange',
            'gestureend',
            'focus',
            'blur',
            'change',
            'reset',
            'select',
            'submit',
            'focusin',
            'focusout',
            'load',
            'unload',
            'beforeunload',
            'resize',
            'move',
            'DOMContentLoaded',
            'readystatechange',
            'error',
            'abort',
            'scroll',
        ])
    function S(b, a) {
        return (a && `${a}::${O++}`) || b.uidEvent || O++
    }
    function T(b) {
        let a = S(b)
        return (b.uidEvent = a), (N[a] = N[a] || {}), N[a]
    }
    function U(c, e, f = null) {
        let d = Object.keys(c)
        for (let a = 0, g = d.length; a < g; a++) {
            let b = c[d[a]]
            if (b.originalHandler === e && b.delegationSelector === f) return b
        }
        return null
    }
    function V(b, c, e) {
        let d = 'string' == typeof c,
            a = Y(b)
        return R.has(a) || (a = b), [d, d ? e : c, a]
    }
    function W(d, e, a, b, j) {
        var o, p, q, r, s
        if ('string' != typeof e || !d) return
        if ((a || ((a = b), (b = null)), Q.test(e))) {
            let k = a =>
                function (b) {
                    if (
                        !b.relatedTarget ||
                        (b.relatedTarget !== b.delegateTarget &&
                            !b.delegateTarget.contains(b.relatedTarget))
                    )
                        return a.call(this, b)
                }
            b ? (b = k(b)) : (a = k(a))
        }
        let [f, g, h] = V(e, a, b),
            l = T(d),
            m = l[h] || (l[h] = {}),
            i = U(m, g, f ? a : null)
        if (i) return void (i.oneOff = i.oneOff && j)
        let n = S(g, e.replace(K, '')),
            c = f
                ? ((o = d),
                  (p = a),
                  (q = b),
                  function e(b) {
                      let c = o.querySelectorAll(p)
                      for (
                          let { target: a } = b;
                          a && a !== this;
                          a = a.parentNode
                      )
                          for (let d = c.length; d--; )
                              if (c[d] === a)
                                  return (
                                      (b.delegateTarget = a),
                                      e.oneOff && $.off(o, b.type, p, q),
                                      q.apply(a, [b])
                                  )
                      return null
                  })
                : ((r = d),
                  (s = a),
                  function b(a) {
                      return (
                          (a.delegateTarget = r),
                          b.oneOff && $.off(r, a.type, s),
                          s.apply(r, [a])
                      )
                  })
        ;(c.delegationSelector = f ? a : null),
            (c.originalHandler = g),
            (c.oneOff = j),
            (c.uidEvent = n),
            (m[n] = c),
            d.addEventListener(h, c, f)
    }
    function X(e, c, a, f, d) {
        let b = U(c[a], f, d)
        b && (e.removeEventListener(a, b, Boolean(d)), delete c[a][b.uidEvent])
    }
    function Y(a) {
        return P[(a = a.replace(L, ''))] || a
    }
    let $ = {
        on(a, b, c, d) {
            W(a, b, c, d, !1)
        },
        one(a, b, c, d) {
            W(a, b, c, d, !0)
        },
        off(d, b, e, g) {
            if ('string' != typeof b || !d) return
            let [h, f, c] = V(b, e, g),
                k = c !== b,
                a = T(d),
                i = b.startsWith('.')
            if (void 0 !== f) {
                if (!a || !a[c]) return
                return void X(d, a, c, f, h ? e : null)
            }
            i &&
                Object.keys(a).forEach(c => {
                    !(function (d, a, b, e) {
                        let c = a[b] || {}
                        Object.keys(c).forEach(f => {
                            if (f.includes(e)) {
                                let g = c[f]
                                X(
                                    d,
                                    a,
                                    b,
                                    g.originalHandler,
                                    g.delegationSelector,
                                )
                            }
                        })
                    })(d, a, c, b.slice(1))
                })
            let j = a[c] || {}
            Object.keys(j).forEach(e => {
                let g = e.replace(M, '')
                if (!k || b.includes(g)) {
                    let f = j[e]
                    X(d, a, c, f.originalHandler, f.delegationSelector)
                }
            })
        },
        trigger(d, c, e) {
            if ('string' != typeof c || !d) return null
            let f = G(),
                g = Y(c),
                k = c !== g,
                l = R.has(g),
                a,
                h = !0,
                i = !0,
                j = !1,
                b = null
            return (
                k &&
                    f &&
                    ((a = f.Event(c, e)),
                    f(d).trigger(a),
                    (h = !a.isPropagationStopped()),
                    (i = !a.isImmediatePropagationStopped()),
                    (j = a.isDefaultPrevented())),
                l
                    ? (b = document.createEvent('HTMLEvents')).initEvent(
                          g,
                          h,
                          !0,
                      )
                    : (b = new CustomEvent(c, { bubbles: h, cancelable: !0 })),
                void 0 !== e &&
                    Object.keys(e).forEach(a => {
                        Object.defineProperty(b, a, { get: () => e[a] })
                    }),
                j && b.preventDefault(),
                i && d.dispatchEvent(b),
                b.defaultPrevented && void 0 !== a && a.preventDefault(),
                b
            )
        },
    }
    class b {
        constructor(a) {
            ;(a = z(a)) &&
                ((this._element = a),
                J.set(this._element, this.constructor.DATA_KEY, this))
        }
        dispose() {
            J.remove(this._element, this.constructor.DATA_KEY),
                $.off(this._element, this.constructor.EVENT_KEY),
                Object.getOwnPropertyNames(this).forEach(a => {
                    this[a] = null
                })
        }
        _queueCallback(b, a, c = !0) {
            if (!c) return void H(b)
            let d = w(a)
            $.one(a, 'transitionend', () => H(b)), A(a, d)
        }
        static getInstance(a) {
            return J.get(a, this.DATA_KEY)
        }
        static get VERSION() {
            return '5.0.1'
        }
        static get NAME() {
            throw new Error(
                'You have to implement the static method "NAME", for each component!',
            )
        }
        static get DATA_KEY() {
            return 'bs.' + this.NAME
        }
        static get EVENT_KEY() {
            return '.' + this.DATA_KEY
        }
    }
    class f extends b {
        static get NAME() {
            return 'alert'
        }
        close(a) {
            let b = a ? this._getRootElement(a) : this._element,
                c = this._triggerCloseEvent(b)
            null === c || c.defaultPrevented || this._removeElement(b)
        }
        _getRootElement(a) {
            return v(a) || a.closest('.alert')
        }
        _triggerCloseEvent(a) {
            return $.trigger(a, 'close.bs.alert')
        }
        _removeElement(a) {
            a.classList.remove('show')
            let b = a.classList.contains('fade')
            this._queueCallback(() => this._destroyElement(a), a, b)
        }
        _destroyElement(a) {
            a.parentNode && a.parentNode.removeChild(a),
                $.trigger(a, 'closed.bs.alert')
        }
        static jQueryInterface(a) {
            return this.each(function () {
                let b = J.get(this, 'bs.alert')
                b || (b = new f(this)), 'close' === a && b[a](this)
            })
        }
        static handleDismiss(a) {
            return function (b) {
                b && b.preventDefault(), a.close(this)
            }
        }
    }
    $.on(
        document,
        'click.bs.alert.data-api',
        '[data-bs-dismiss="alert"]',
        f.handleDismiss(new f()),
    ),
        a(f)
    class h extends b {
        static get NAME() {
            return 'button'
        }
        toggle() {
            this._element.setAttribute(
                'aria-pressed',
                this._element.classList.toggle('active'),
            )
        }
        static jQueryInterface(a) {
            return this.each(function () {
                let b = J.get(this, 'bs.button')
                b || (b = new h(this)), 'toggle' === a && b[a]()
            })
        }
    }
    function Z(a) {
        return (
            'true' === a ||
            ('false' !== a &&
                (a === Number(a).toString()
                    ? Number(a)
                    : '' === a || 'null' === a
                    ? null
                    : a))
        )
    }
    function aa(a) {
        return a.replace(/[A-Z]/g, a => '-' + a.toLowerCase())
    }
    $.on(
        document,
        'click.bs.button.data-api',
        '[data-bs-toggle="button"]',
        b => {
            b.preventDefault()
            let c = b.target.closest('[data-bs-toggle="button"]'),
                a = J.get(c, 'bs.button')
            a || (a = new h(c)), a.toggle()
        },
    ),
        a(h)
    let ab = {
            setDataAttribute(a, b, c) {
                a.setAttribute('data-bs-' + aa(b), c)
            },
            removeDataAttribute(a, b) {
                a.removeAttribute('data-bs-' + aa(b))
            },
            getDataAttributes(a) {
                if (!a) return {}
                let b = {}
                return (
                    Object.keys(a.dataset)
                        .filter(a => a.startsWith('bs'))
                        .forEach(d => {
                            let c = d.replace(/^bs/, '')
                            b[
                                (c =
                                    c.charAt(0).toLowerCase() +
                                    c.slice(1, c.length))
                            ] = Z(a.dataset[d])
                        }),
                    b
                )
            },
            getDataAttribute: (a, b) => Z(a.getAttribute('data-bs-' + aa(b))),
            offset(b) {
                let a = b.getBoundingClientRect()
                return {
                    top: a.top + document.body.scrollTop,
                    left: a.left + document.body.scrollLeft,
                }
            },
            position: a => ({ top: a.offsetTop, left: a.offsetLeft }),
        },
        ac = {
            interval: 5e3,
            keyboard: !0,
            slide: !1,
            pause: 'hover',
            wrap: !0,
            touch: !0,
        },
        ad = {
            interval: '(number|boolean)',
            keyboard: 'boolean',
            slide: '(boolean|string)',
            pause: '(string|boolean)',
            wrap: 'boolean',
            touch: 'boolean',
        },
        ae = 'next',
        af = 'prev',
        ag = 'left',
        ah = 'right'
    class g extends b {
        constructor(a, b) {
            super(a),
                (this._items = null),
                (this._interval = null),
                (this._activeElement = null),
                (this._isPaused = !1),
                (this._isSliding = !1),
                (this.touchTimeout = null),
                (this.touchStartX = 0),
                (this.touchDeltaX = 0),
                (this._config = this._getConfig(b)),
                (this._indicatorsElement = r.findOne(
                    '.carousel-indicators',
                    this._element,
                )),
                (this._touchSupported =
                    'ontouchstart' in document.documentElement ||
                    navigator.maxTouchPoints > 0),
                (this._pointerEvent = Boolean(window.PointerEvent)),
                this._addEventListeners()
        }
        static get Default() {
            return ac
        }
        static get NAME() {
            return 'carousel'
        }
        next() {
            this._isSliding || this._slide(ae)
        }
        nextWhenVisible() {
            !document.hidden && C(this._element) && this.next()
        }
        prev() {
            this._isSliding || this._slide(af)
        }
        pause(a) {
            a || (this._isPaused = !0),
                r.findOne(
                    '.carousel-item-next, .carousel-item-prev',
                    this._element,
                ) && (x(this._element), this.cycle(!0)),
                clearInterval(this._interval),
                (this._interval = null)
        }
        cycle(a) {
            a || (this._isPaused = !1),
                this._interval &&
                    (clearInterval(this._interval), (this._interval = null)),
                this._config &&
                    this._config.interval &&
                    !this._isPaused &&
                    (this._updateInterval(),
                    (this._interval = setInterval(
                        (document.visibilityState
                            ? this.nextWhenVisible
                            : this.next
                        ).bind(this),
                        this._config.interval,
                    )))
        }
        to(a) {
            this._activeElement = r.findOne(
                '.active.carousel-item',
                this._element,
            )
            let b = this._getItemIndex(this._activeElement)
            if (a > this._items.length - 1 || a < 0) return
            if (this._isSliding)
                return void $.one(this._element, 'slid.bs.carousel', () =>
                    this.to(a),
                )
            if (b === a) return this.pause(), void this.cycle()
            let c = a > b ? ae : af
            this._slide(c, this._items[a])
        }
        _getConfig(a) {
            return (a = { ...ac, ...a }), B('carousel', a, ad), a
        }
        _handleSwipe() {
            let a = Math.abs(this.touchDeltaX)
            if (a <= 40) return
            let b = a / this.touchDeltaX
            ;(this.touchDeltaX = 0), b && this._slide(b > 0 ? ah : ag)
        }
        _addEventListeners() {
            this._config.keyboard &&
                $.on(this._element, 'keydown.bs.carousel', a =>
                    this._keydown(a),
                ),
                'hover' === this._config.pause &&
                    ($.on(this._element, 'mouseenter.bs.carousel', a =>
                        this.pause(a),
                    ),
                    $.on(this._element, 'mouseleave.bs.carousel', a =>
                        this.cycle(a),
                    )),
                this._config.touch &&
                    this._touchSupported &&
                    this._addTouchEventListeners()
        }
        _addTouchEventListeners() {
            let a = a => {
                    this._pointerEvent &&
                    ('pen' === a.pointerType || 'touch' === a.pointerType)
                        ? (this.touchStartX = a.clientX)
                        : this._pointerEvent ||
                          (this.touchStartX = a.touches[0].clientX)
                },
                b = a => {
                    this.touchDeltaX =
                        a.touches && a.touches.length > 1
                            ? 0
                            : a.touches[0].clientX - this.touchStartX
                },
                c = a => {
                    this._pointerEvent &&
                        ('pen' === a.pointerType ||
                            'touch' === a.pointerType) &&
                        (this.touchDeltaX = a.clientX - this.touchStartX),
                        this._handleSwipe(),
                        'hover' === this._config.pause &&
                            (this.pause(),
                            this.touchTimeout &&
                                clearTimeout(this.touchTimeout),
                            (this.touchTimeout = setTimeout(
                                a => this.cycle(a),
                                500 + this._config.interval,
                            )))
                }
            r.find('.carousel-item img', this._element).forEach(a => {
                $.on(a, 'dragstart.bs.carousel', a => a.preventDefault())
            }),
                this._pointerEvent
                    ? ($.on(this._element, 'pointerdown.bs.carousel', b =>
                          a(b),
                      ),
                      $.on(this._element, 'pointerup.bs.carousel', a => c(a)),
                      this._element.classList.add('pointer-event'))
                    : ($.on(this._element, 'touchstart.bs.carousel', b => a(b)),
                      $.on(this._element, 'touchmove.bs.carousel', a => b(a)),
                      $.on(this._element, 'touchend.bs.carousel', a => c(a)))
        }
        _keydown(a) {
            ;/input|textarea/i.test(a.target.tagName) ||
                ('ArrowLeft' === a.key
                    ? (a.preventDefault(), this._slide(ah))
                    : 'ArrowRight' === a.key &&
                      (a.preventDefault(), this._slide(ag)))
        }
        _getItemIndex(a) {
            return (
                (this._items =
                    a && a.parentNode
                        ? r.find('.carousel-item', a.parentNode)
                        : []),
                this._items.indexOf(a)
            )
        }
        _getItemByOrder(b, c) {
            let d = b === af,
                a = this._getItemIndex(c),
                f = this._items.length - 1
            if (((d && 0 === a) || (b === ae && a === f)) && !this._config.wrap)
                return c
            let e = (a + (d ? -1 : 1)) % this._items.length
            return -1 === e
                ? this._items[this._items.length - 1]
                : this._items[e]
        }
        _triggerSlideEvent(a, b) {
            let c = this._getItemIndex(a),
                d = this._getItemIndex(
                    r.findOne('.active.carousel-item', this._element),
                )
            return $.trigger(this._element, 'slide.bs.carousel', {
                relatedTarget: a,
                direction: b,
                from: d,
                to: c,
            })
        }
        _setActiveIndicatorElement(d) {
            if (this._indicatorsElement) {
                let c = r.findOne('.active', this._indicatorsElement)
                c.classList.remove('active'), c.removeAttribute('aria-current')
                let b = r.find('[data-bs-target]', this._indicatorsElement)
                for (let a = 0; a < b.length; a++)
                    if (
                        Number.parseInt(
                            b[a].getAttribute('data-bs-slide-to'),
                            10,
                        ) === this._getItemIndex(d)
                    ) {
                        b[a].classList.add('active'),
                            b[a].setAttribute('aria-current', 'true')
                        break
                    }
            }
        }
        _updateInterval() {
            let a =
                this._activeElement ||
                r.findOne('.active.carousel-item', this._element)
            if (!a) return
            let b = Number.parseInt(a.getAttribute('data-bs-interval'), 10)
            b
                ? ((this._config.defaultInterval =
                      this._config.defaultInterval || this._config.interval),
                  (this._config.interval = b))
                : (this._config.interval =
                      this._config.defaultInterval || this._config.interval)
        }
        _slide(g, h) {
            let c = this._directionToOrder(g),
                b = r.findOne('.active.carousel-item', this._element),
                m = this._getItemIndex(b),
                a = h || this._getItemByOrder(c, b),
                n = this._getItemIndex(a),
                d = Boolean(this._interval),
                e = c === ae,
                f = e ? 'carousel-item-start' : 'carousel-item-end',
                i = e ? 'carousel-item-next' : 'carousel-item-prev',
                j = this._orderToDirection(c)
            if (a && a.classList.contains('active'))
                return void (this._isSliding = !1)
            if (this._triggerSlideEvent(a, j).defaultPrevented || !b || !a)
                return
            ;(this._isSliding = !0),
                d && this.pause(),
                this._setActiveIndicatorElement(a),
                (this._activeElement = a)
            let k = () => {
                $.trigger(this._element, 'slid.bs.carousel', {
                    relatedTarget: a,
                    direction: j,
                    from: m,
                    to: n,
                })
            }
            if (this._element.classList.contains('slide')) {
                a.classList.add(i), F(a), b.classList.add(f), a.classList.add(f)
                let l = () => {
                    a.classList.remove(f, i),
                        a.classList.add('active'),
                        b.classList.remove('active', i, f),
                        (this._isSliding = !1),
                        setTimeout(k, 0)
                }
                this._queueCallback(l, b, !0)
            } else b.classList.remove('active'), a.classList.add('active'), (this._isSliding = !1), k()
            d && this.cycle()
        }
        _directionToOrder(a) {
            return [ah, ag].includes(a)
                ? c()
                    ? a === ag
                        ? af
                        : ae
                    : a === ag
                    ? ae
                    : af
                : a
        }
        _orderToDirection(a) {
            return [ae, af].includes(a)
                ? c()
                    ? a === af
                        ? ag
                        : ah
                    : a === af
                    ? ah
                    : ag
                : a
        }
        static carouselInterface(e, b) {
            let a = J.get(e, 'bs.carousel'),
                c = { ...ac, ...ab.getDataAttributes(e) }
            'object' == typeof b && (c = { ...c, ...b })
            let d = 'string' == typeof b ? b : c.slide
            if ((a || (a = new g(e, c)), 'number' == typeof b)) a.to(b)
            else if ('string' == typeof d) {
                if (void 0 === a[d])
                    throw new TypeError(`No method named "${d}"`)
                a[d]()
            } else c.interval && c.ride && (a.pause(), a.cycle())
        }
        static jQueryInterface(a) {
            return this.each(function () {
                g.carouselInterface(this, a)
            })
        }
        static dataApiClickHandler(d) {
            let a = v(this)
            if (!a || !a.classList.contains('carousel')) return
            let c = {
                    ...ab.getDataAttributes(a),
                    ...ab.getDataAttributes(this),
                },
                b = this.getAttribute('data-bs-slide-to')
            b && (c.interval = !1),
                g.carouselInterface(a, c),
                b && J.get(a, 'bs.carousel').to(b),
                d.preventDefault()
        }
    }
    $.on(
        document,
        'click.bs.carousel.data-api',
        '[data-bs-slide], [data-bs-slide-to]',
        g.dataApiClickHandler,
    ),
        $.on(window, 'load.bs.carousel.data-api', () => {
            let b = r.find('[data-bs-ride="carousel"]')
            for (let a = 0, c = b.length; a < c; a++)
                g.carouselInterface(b[a], J.get(b[a], 'bs.carousel'))
        }),
        a(g)
    let ai = { toggle: !0, parent: '' },
        aj = { toggle: 'boolean', parent: '(string|element)' }
    class i extends b {
        constructor(e, f) {
            super(e),
                (this._isTransitioning = !1),
                (this._config = this._getConfig(f)),
                (this._triggerArray = r.find(
                    `[data-bs-toggle="collapse"][href="#${this._element.id}"],[data-bs-toggle="collapse"][data-bs-target="#${this._element.id}"]`,
                ))
            let c = r.find('[data-bs-toggle="collapse"]')
            for (let a = 0, g = c.length; a < g; a++) {
                let d = c[a],
                    b = u(d),
                    h = r.find(b).filter(a => a === this._element)
                null !== b &&
                    h.length &&
                    ((this._selector = b), this._triggerArray.push(d))
            }
            ;(this._parent = this._config.parent ? this._getParent() : null),
                this._config.parent ||
                    this._addAriaAndCollapsedClass(
                        this._element,
                        this._triggerArray,
                    ),
                this._config.toggle && this.toggle()
        }
        static get Default() {
            return ai
        }
        static get NAME() {
            return 'collapse'
        }
        toggle() {
            this._element.classList.contains('show') ? this.hide() : this.show()
        }
        show() {
            if (
                this._isTransitioning ||
                this._element.classList.contains('show')
            )
                return
            let a, c
            this._parent &&
                0 ===
                    (a = r
                        .find('.show, .collapsing', this._parent)
                        .filter(a =>
                            'string' == typeof this._config.parent
                                ? a.getAttribute('data-bs-parent') ===
                                  this._config.parent
                                : a.classList.contains('collapse'),
                        )).length &&
                (a = null)
            let f = r.findOne(this._selector)
            if (a) {
                let d = a.find(a => f !== a)
                if (
                    (c = d ? J.get(d, 'bs.collapse') : null) &&
                    c._isTransitioning
                )
                    return
            }
            if ($.trigger(this._element, 'show.bs.collapse').defaultPrevented)
                return
            a &&
                a.forEach(a => {
                    f !== a && i.collapseInterface(a, 'hide'),
                        c || J.set(a, 'bs.collapse', null)
                })
            let b = this._getDimension()
            this._element.classList.remove('collapse'),
                this._element.classList.add('collapsing'),
                (this._element.style[b] = 0),
                this._triggerArray.length &&
                    this._triggerArray.forEach(a => {
                        a.classList.remove('collapsed'),
                            a.setAttribute('aria-expanded', !0)
                    }),
                this.setTransitioning(!0)
            let e = 'scroll' + (b[0].toUpperCase() + b.slice(1))
            this._queueCallback(
                () => {
                    this._element.classList.remove('collapsing'),
                        this._element.classList.add('collapse', 'show'),
                        (this._element.style[b] = ''),
                        this.setTransitioning(!1),
                        $.trigger(this._element, 'shown.bs.collapse')
                },
                this._element,
                !0,
            ),
                (this._element.style[b] = this._element[e] + 'px')
        }
        hide() {
            if (
                this._isTransitioning ||
                !this._element.classList.contains('show') ||
                $.trigger(this._element, 'hide.bs.collapse').defaultPrevented
            )
                return
            let a = this._getDimension()
            ;(this._element.style[a] =
                this._element.getBoundingClientRect()[a] + 'px'),
                F(this._element),
                this._element.classList.add('collapsing'),
                this._element.classList.remove('collapse', 'show')
            let d = this._triggerArray.length
            if (d > 0)
                for (let b = 0; b < d; b++) {
                    let c = this._triggerArray[b],
                        e = v(c)
                    e &&
                        !e.classList.contains('show') &&
                        (c.classList.add('collapsed'),
                        c.setAttribute('aria-expanded', !1))
                }
            this.setTransitioning(!0),
                (this._element.style[a] = ''),
                this._queueCallback(
                    () => {
                        this.setTransitioning(!1),
                            this._element.classList.remove('collapsing'),
                            this._element.classList.add('collapse'),
                            $.trigger(this._element, 'hidden.bs.collapse')
                    },
                    this._element,
                    !0,
                )
        }
        setTransitioning(a) {
            this._isTransitioning = a
        }
        _getConfig(a) {
            return (
                ((a = { ...ai, ...a }).toggle = Boolean(a.toggle)),
                B('collapse', a, aj),
                a
            )
        }
        _getDimension() {
            return this._element.classList.contains('width')
                ? 'width'
                : 'height'
        }
        _getParent() {
            let { parent: a } = this._config
            a = z(a)
            let b = `[data-bs-toggle="collapse"][data-bs-parent="${a}"]`
            return (
                r.find(b, a).forEach(a => {
                    let b = v(a)
                    this._addAriaAndCollapsedClass(b, [a])
                }),
                a
            )
        }
        _addAriaAndCollapsedClass(a, b) {
            if (!a || !b.length) return
            let c = a.classList.contains('show')
            b.forEach(a => {
                c
                    ? a.classList.remove('collapsed')
                    : a.classList.add('collapsed'),
                    a.setAttribute('aria-expanded', c)
            })
        }
        static collapseInterface(c, a) {
            let b = J.get(c, 'bs.collapse'),
                d = {
                    ...ai,
                    ...ab.getDataAttributes(c),
                    ...('object' == typeof a && a ? a : {}),
                }
            if (
                (!b &&
                    d.toggle &&
                    'string' == typeof a &&
                    /show|hide/.test(a) &&
                    (d.toggle = !1),
                b || (b = new i(c, d)),
                'string' == typeof a)
            ) {
                if (void 0 === b[a])
                    throw new TypeError(`No method named "${a}"`)
                b[a]()
            }
        }
        static jQueryInterface(a) {
            return this.each(function () {
                i.collapseInterface(this, a)
            })
        }
    }
    $.on(
        document,
        'click.bs.collapse.data-api',
        '[data-bs-toggle="collapse"]',
        function (a) {
            ;('A' === a.target.tagName ||
                (a.delegateTarget && 'A' === a.delegateTarget.tagName)) &&
                a.preventDefault()
            let c = ab.getDataAttributes(this),
                b = u(this)
            r.find(b).forEach(d => {
                let a = J.get(d, 'bs.collapse'),
                    b
                a
                    ? (null === a._parent &&
                          'string' == typeof c.parent &&
                          ((a._config.parent = c.parent),
                          (a._parent = a._getParent())),
                      (b = 'toggle'))
                    : (b = c),
                    i.collapseInterface(d, b)
            })
        },
    ),
        a(i)
    let ak = new RegExp('ArrowUp|ArrowDown|Escape'),
        al = c() ? 'top-end' : 'top-start',
        am = c() ? 'top-start' : 'top-end',
        an = c() ? 'bottom-end' : 'bottom-start',
        ao = c() ? 'bottom-start' : 'bottom-end',
        ap = c() ? 'left-start' : 'right-start',
        aq = c() ? 'right-start' : 'left-start',
        ar = {
            offset: [0, 2],
            boundary: 'clippingParents',
            reference: 'toggle',
            display: 'dynamic',
            popperConfig: null,
            autoClose: !0,
        },
        as = {
            offset: '(array|string|function)',
            boundary: '(string|element)',
            reference: '(string|element|object)',
            display: 'string',
            popperConfig: '(null|object|function)',
            autoClose: '(boolean|string)',
        }
    class d extends b {
        constructor(a, b) {
            super(a),
                (this._popper = null),
                (this._config = this._getConfig(b)),
                (this._menu = this._getMenuElement()),
                (this._inNavbar = this._detectNavbar()),
                this._addEventListeners()
        }
        static get Default() {
            return ar
        }
        static get DefaultType() {
            return as
        }
        static get NAME() {
            return 'dropdown'
        }
        toggle() {
            D(this._element) ||
                (this._element.classList.contains('show')
                    ? this.hide()
                    : this.show())
        }
        show() {
            if (D(this._element) || this._menu.classList.contains('show'))
                return
            let b = d.getParentFromElement(this._element),
                c = { relatedTarget: this._element }
            if (
                !$.trigger(this._element, 'show.bs.dropdown', c)
                    .defaultPrevented
            ) {
                if (this._inNavbar)
                    ab.setDataAttribute(this._menu, 'popper', 'none')
                else {
                    if (void 0 === q)
                        throw new TypeError(
                            "Bootstrap's dropdowns require Popper (https://popper.js.org)",
                        )
                    let a = this._element
                    'parent' === this._config.reference
                        ? (a = b)
                        : y(this._config.reference)
                        ? (a = z(this._config.reference))
                        : 'object' == typeof this._config.reference &&
                          (a = this._config.reference)
                    let e = this._getPopperConfig(),
                        f = e.modifiers.find(
                            a => 'applyStyles' === a.name && !1 === a.enabled,
                        )
                    ;(this._popper = q.createPopper(a, this._menu, e)),
                        f && ab.setDataAttribute(this._menu, 'popper', 'static')
                }
                'ontouchstart' in document.documentElement &&
                    !b.closest('.navbar-nav') &&
                    []
                        .concat(...document.body.children)
                        .forEach(a => $.on(a, 'mouseover', _)),
                    this._element.focus(),
                    this._element.setAttribute('aria-expanded', !0),
                    this._menu.classList.toggle('show'),
                    this._element.classList.toggle('show'),
                    $.trigger(this._element, 'shown.bs.dropdown', c)
            }
        }
        hide() {
            if (D(this._element) || !this._menu.classList.contains('show'))
                return
            let a = { relatedTarget: this._element }
            this._completeHide(a)
        }
        dispose() {
            this._popper && this._popper.destroy(), super.dispose()
        }
        update() {
            ;(this._inNavbar = this._detectNavbar()),
                this._popper && this._popper.update()
        }
        _addEventListeners() {
            $.on(this._element, 'click.bs.dropdown', a => {
                a.preventDefault(), this.toggle()
            })
        }
        _completeHide(a) {
            $.trigger(this._element, 'hide.bs.dropdown', a).defaultPrevented ||
                ('ontouchstart' in document.documentElement &&
                    []
                        .concat(...document.body.children)
                        .forEach(a => $.off(a, 'mouseover', _)),
                this._popper && this._popper.destroy(),
                this._menu.classList.remove('show'),
                this._element.classList.remove('show'),
                this._element.setAttribute('aria-expanded', 'false'),
                ab.removeDataAttribute(this._menu, 'popper'),
                $.trigger(this._element, 'hidden.bs.dropdown', a))
        }
        _getConfig(a) {
            if (
                (B(
                    'dropdown',
                    (a = {
                        ...this.constructor.Default,
                        ...ab.getDataAttributes(this._element),
                        ...a,
                    }),
                    this.constructor.DefaultType,
                ),
                'object' == typeof a.reference &&
                    !y(a.reference) &&
                    'function' != typeof a.reference.getBoundingClientRect)
            )
                throw new TypeError(
                    'DROPDOWN: Option "reference" provided type "object" without a required "getBoundingClientRect" method.',
                )
            return a
        }
        _getMenuElement() {
            return r.next(this._element, '.dropdown-menu')[0]
        }
        _getPlacement() {
            let a = this._element.parentNode
            if (a.classList.contains('dropend')) return ap
            if (a.classList.contains('dropstart')) return aq
            let b =
                'end' ===
                getComputedStyle(this._menu)
                    .getPropertyValue('--bs-position')
                    .trim()
            return a.classList.contains('dropup') ? (b ? am : al) : b ? ao : an
        }
        _detectNavbar() {
            return null !== this._element.closest('.navbar')
        }
        _getOffset() {
            let { offset: a } = this._config
            return 'string' == typeof a
                ? a.split(',').map(a => Number.parseInt(a, 10))
                : 'function' == typeof a
                ? b => a(b, this._element)
                : a
        }
        _getPopperConfig() {
            let a = {
                placement: this._getPlacement(),
                modifiers: [
                    {
                        name: 'preventOverflow',
                        options: { boundary: this._config.boundary },
                    },
                    { name: 'offset', options: { offset: this._getOffset() } },
                ],
            }
            return (
                'static' === this._config.display &&
                    (a.modifiers = [{ name: 'applyStyles', enabled: !1 }]),
                {
                    ...a,
                    ...('function' == typeof this._config.popperConfig
                        ? this._config.popperConfig(a)
                        : this._config.popperConfig),
                }
            )
        }
        _selectMenuItem(c) {
            let b = r
                .find(
                    '.dropdown-menu .dropdown-item:not(.disabled):not(:disabled)',
                    this._menu,
                )
                .filter(C)
            if (!b.length) return
            let a = b.indexOf(c.target)
            'ArrowUp' === c.key && a > 0 && a--,
                'ArrowDown' === c.key && a < b.length - 1 && a++,
                b[(a = -1 === a ? 0 : a)].focus()
        }
        static dropdownInterface(c, a) {
            let b = J.get(c, 'bs.dropdown')
            if (
                (b || (b = new d(c, 'object' == typeof a ? a : null)),
                'string' == typeof a)
            ) {
                if (void 0 === b[a])
                    throw new TypeError(`No method named "${a}"`)
                b[a]()
            }
        }
        static jQueryInterface(a) {
            return this.each(function () {
                d.dropdownInterface(this, a)
            })
        }
        static clearMenus(a) {
            if (
                a &&
                (2 === a.button || ('keyup' === a.type && 'Tab' !== a.key))
            )
                return
            let d = r.find('[data-bs-toggle="dropdown"]')
            for (let c = 0, h = d.length; c < h; c++) {
                let b = J.get(d[c], 'bs.dropdown')
                if (
                    !b ||
                    !1 === b._config.autoClose ||
                    !b._element.classList.contains('show')
                )
                    continue
                let e = { relatedTarget: b._element }
                if (a) {
                    let f = a.composedPath(),
                        g = f.includes(b._menu)
                    if (
                        f.includes(b._element) ||
                        ('inside' === b._config.autoClose && !g) ||
                        ('outside' === b._config.autoClose && g) ||
                        (b._menu.contains(a.target) &&
                            (('keyup' === a.type && 'Tab' === a.key) ||
                                /input|select|option|textarea|form/i.test(
                                    a.target.tagName,
                                )))
                    )
                        continue
                    'click' === a.type && (e.clickEvent = a)
                }
                b._completeHide(e)
            }
        }
        static getParentFromElement(a) {
            return v(a) || a.parentNode
        }
        static dataApiKeydownHandler(a) {
            if (
                /input|textarea/i.test(a.target.tagName)
                    ? 'Space' === a.key ||
                      ('Escape' !== a.key &&
                          (('ArrowDown' !== a.key && 'ArrowUp' !== a.key) ||
                              a.target.closest('.dropdown-menu')))
                    : !ak.test(a.key)
            )
                return
            let b = this.classList.contains('show')
            if (
                (!b && 'Escape' === a.key) ||
                (a.preventDefault(), a.stopPropagation(), D(this))
            )
                return
            let c = () =>
                this.matches('[data-bs-toggle="dropdown"]')
                    ? this
                    : r.prev(this, '[data-bs-toggle="dropdown"]')[0]
            if ('Escape' === a.key) return c().focus(), void d.clearMenus()
            b || ('ArrowUp' !== a.key && 'ArrowDown' !== a.key)
                ? b && 'Space' !== a.key
                    ? d.getInstance(c())._selectMenuItem(a)
                    : d.clearMenus()
                : c().click()
        }
    }
    $.on(
        document,
        'keydown.bs.dropdown.data-api',
        '[data-bs-toggle="dropdown"]',
        d.dataApiKeydownHandler,
    ),
        $.on(
            document,
            'keydown.bs.dropdown.data-api',
            '.dropdown-menu',
            d.dataApiKeydownHandler,
        ),
        $.on(document, 'click.bs.dropdown.data-api', d.clearMenus),
        $.on(document, 'keyup.bs.dropdown.data-api', d.clearMenus),
        $.on(
            document,
            'click.bs.dropdown.data-api',
            '[data-bs-toggle="dropdown"]',
            function (a) {
                a.preventDefault(), d.dropdownInterface(this)
            },
        ),
        a(d)
    let at = () => {
            let a = document.documentElement.clientWidth
            return Math.abs(window.innerWidth - a)
        },
        au = (a = at()) => {
            av(),
                aw('body', 'paddingRight', b => b + a),
                aw(
                    '.fixed-top, .fixed-bottom, .is-fixed, .sticky-top',
                    'paddingRight',
                    b => b + a,
                ),
                aw('.sticky-top', 'marginRight', b => b - a)
        },
        av = () => {
            let a = document.body.style.overflow
            a && ab.setDataAttribute(document.body, 'overflow', a),
                (document.body.style.overflow = 'hidden')
        },
        aw = (a, b, c) => {
            let d = at()
            r.find(a).forEach(a => {
                if (
                    a !== document.body &&
                    window.innerWidth > a.clientWidth + d
                )
                    return
                let e = a.style[b],
                    f = window.getComputedStyle(a)[b]
                ab.setDataAttribute(a, b, e),
                    (a.style[b] = c(Number.parseFloat(f)) + 'px')
            })
        },
        ax = () => {
            ay('body', 'overflow'),
                ay('body', 'paddingRight'),
                ay(
                    '.fixed-top, .fixed-bottom, .is-fixed, .sticky-top',
                    'paddingRight',
                ),
                ay('.sticky-top', 'marginRight')
        },
        ay = (a, b) => {
            r.find(a).forEach(a => {
                let c = ab.getDataAttribute(a, b)
                void 0 === c
                    ? a.style.removeProperty(b)
                    : (ab.removeDataAttribute(a, b), (a.style[b] = c))
            })
        },
        az = {
            isVisible: !0,
            isAnimated: !1,
            rootElement: document.body,
            clickCallback: null,
        },
        aA = {
            isVisible: 'boolean',
            isAnimated: 'boolean',
            rootElement: 'element',
            clickCallback: '(function|null)',
        }
    class aB {
        constructor(a) {
            ;(this._config = this._getConfig(a)),
                (this._isAppended = !1),
                (this._element = null)
        }
        show(a) {
            this._config.isVisible
                ? (this._append(),
                  this._config.isAnimated && F(this._getElement()),
                  this._getElement().classList.add('show'),
                  this._emulateAnimation(() => {
                      H(a)
                  }))
                : H(a)
        }
        hide(a) {
            this._config.isVisible
                ? (this._getElement().classList.remove('show'),
                  this._emulateAnimation(() => {
                      this.dispose(), H(a)
                  }))
                : H(a)
        }
        _getElement() {
            if (!this._element) {
                let a = document.createElement('div')
                ;(a.className = 'modal-backdrop'),
                    this._config.isAnimated && a.classList.add('fade'),
                    (this._element = a)
            }
            return this._element
        }
        _getConfig(a) {
            return (
                ((a = {
                    ...az,
                    ...('object' == typeof a ? a : {}),
                }).rootElement = a.rootElement || document.body),
                B('backdrop', a, aA),
                a
            )
        }
        _append() {
            this._isAppended ||
                (this._config.rootElement.appendChild(this._getElement()),
                $.on(this._getElement(), 'mousedown.bs.backdrop', () => {
                    H(this._config.clickCallback)
                }),
                (this._isAppended = !0))
        }
        dispose() {
            this._isAppended &&
                ($.off(this._element, 'mousedown.bs.backdrop'),
                this._getElement().parentNode.removeChild(this._element),
                (this._isAppended = !1))
        }
        _emulateAnimation(a) {
            if (!this._config.isAnimated) return void H(a)
            let b = w(this._getElement())
            $.one(this._getElement(), 'transitionend', () => H(a)),
                A(this._getElement(), b)
        }
    }
    let aC = { backdrop: !0, keyboard: !0, focus: !0 },
        aD = {
            backdrop: '(boolean|string)',
            keyboard: 'boolean',
            focus: 'boolean',
        }
    class j extends b {
        constructor(a, b) {
            super(a),
                (this._config = this._getConfig(b)),
                (this._dialog = r.findOne('.modal-dialog', this._element)),
                (this._backdrop = this._initializeBackDrop()),
                (this._isShown = !1),
                (this._ignoreBackdropClick = !1),
                (this._isTransitioning = !1)
        }
        static get Default() {
            return aC
        }
        static get NAME() {
            return 'modal'
        }
        toggle(a) {
            return this._isShown ? this.hide() : this.show(a)
        }
        show(a) {
            if (this._isShown || this._isTransitioning) return
            this._isAnimated() && (this._isTransitioning = !0)
            let b = $.trigger(this._element, 'show.bs.modal', {
                relatedTarget: a,
            })
            this._isShown ||
                b.defaultPrevented ||
                ((this._isShown = !0),
                au(),
                document.body.classList.add('modal-open'),
                this._adjustDialog(),
                this._setEscapeEvent(),
                this._setResizeEvent(),
                $.on(
                    this._element,
                    'click.dismiss.bs.modal',
                    '[data-bs-dismiss="modal"]',
                    a => this.hide(a),
                ),
                $.on(this._dialog, 'mousedown.dismiss.bs.modal', () => {
                    $.one(this._element, 'mouseup.dismiss.bs.modal', a => {
                        a.target === this._element &&
                            (this._ignoreBackdropClick = !0)
                    })
                }),
                this._showBackdrop(() => this._showElement(a)))
        }
        hide(a) {
            if (
                (a && a.preventDefault(),
                !this._isShown ||
                    this._isTransitioning ||
                    $.trigger(this._element, 'hide.bs.modal').defaultPrevented)
            )
                return
            this._isShown = !1
            let b = this._isAnimated()
            b && (this._isTransitioning = !0),
                this._setEscapeEvent(),
                this._setResizeEvent(),
                $.off(document, 'focusin.bs.modal'),
                this._element.classList.remove('show'),
                $.off(this._element, 'click.dismiss.bs.modal'),
                $.off(this._dialog, 'mousedown.dismiss.bs.modal'),
                this._queueCallback(() => this._hideModal(), this._element, b)
        }
        dispose() {
            ;[window, this._dialog].forEach(a => $.off(a, '.bs.modal')),
                this._backdrop.dispose(),
                super.dispose(),
                $.off(document, 'focusin.bs.modal')
        }
        handleUpdate() {
            this._adjustDialog()
        }
        _initializeBackDrop() {
            return new aB({
                isVisible: Boolean(this._config.backdrop),
                isAnimated: this._isAnimated(),
            })
        }
        _getConfig(a) {
            return (
                B(
                    'modal',
                    (a = {
                        ...aC,
                        ...ab.getDataAttributes(this._element),
                        ...a,
                    }),
                    aD,
                ),
                a
            )
        }
        _showElement(c) {
            let a = this._isAnimated(),
                b = r.findOne('.modal-body', this._dialog)
            ;(this._element.parentNode &&
                this._element.parentNode.nodeType === Node.ELEMENT_NODE) ||
                document.body.appendChild(this._element),
                (this._element.style.display = 'block'),
                this._element.removeAttribute('aria-hidden'),
                this._element.setAttribute('aria-modal', !0),
                this._element.setAttribute('role', 'dialog'),
                (this._element.scrollTop = 0),
                b && (b.scrollTop = 0),
                a && F(this._element),
                this._element.classList.add('show'),
                this._config.focus && this._enforceFocus(),
                this._queueCallback(
                    () => {
                        this._config.focus && this._element.focus(),
                            (this._isTransitioning = !1),
                            $.trigger(this._element, 'shown.bs.modal', {
                                relatedTarget: c,
                            })
                    },
                    this._dialog,
                    a,
                )
        }
        _enforceFocus() {
            $.off(document, 'focusin.bs.modal'),
                $.on(document, 'focusin.bs.modal', a => {
                    document === a.target ||
                        this._element === a.target ||
                        this._element.contains(a.target) ||
                        this._element.focus()
                })
        }
        _setEscapeEvent() {
            this._isShown
                ? $.on(this._element, 'keydown.dismiss.bs.modal', a => {
                      this._config.keyboard && 'Escape' === a.key
                          ? (a.preventDefault(), this.hide())
                          : this._config.keyboard ||
                            'Escape' !== a.key ||
                            this._triggerBackdropTransition()
                  })
                : $.off(this._element, 'keydown.dismiss.bs.modal')
        }
        _setResizeEvent() {
            this._isShown
                ? $.on(window, 'resize.bs.modal', () => this._adjustDialog())
                : $.off(window, 'resize.bs.modal')
        }
        _hideModal() {
            ;(this._element.style.display = 'none'),
                this._element.setAttribute('aria-hidden', !0),
                this._element.removeAttribute('aria-modal'),
                this._element.removeAttribute('role'),
                (this._isTransitioning = !1),
                this._backdrop.hide(() => {
                    document.body.classList.remove('modal-open'),
                        this._resetAdjustments(),
                        ax(),
                        $.trigger(this._element, 'hidden.bs.modal')
                })
        }
        _showBackdrop(a) {
            $.on(this._element, 'click.dismiss.bs.modal', a => {
                this._ignoreBackdropClick
                    ? (this._ignoreBackdropClick = !1)
                    : a.target === a.currentTarget &&
                      (!0 === this._config.backdrop
                          ? this.hide()
                          : 'static' === this._config.backdrop &&
                            this._triggerBackdropTransition())
            }),
                this._backdrop.show(a)
        }
        _isAnimated() {
            return this._element.classList.contains('fade')
        }
        _triggerBackdropTransition() {
            if (
                $.trigger(this._element, 'hidePrevented.bs.modal')
                    .defaultPrevented
            )
                return
            let a =
                this._element.scrollHeight >
                document.documentElement.clientHeight
            a || (this._element.style.overflowY = 'hidden'),
                this._element.classList.add('modal-static')
            let b = w(this._dialog)
            $.off(this._element, 'transitionend'),
                $.one(this._element, 'transitionend', () => {
                    this._element.classList.remove('modal-static'),
                        a ||
                            ($.one(this._element, 'transitionend', () => {
                                this._element.style.overflowY = ''
                            }),
                            A(this._element, b))
                }),
                A(this._element, b),
                this._element.focus()
        }
        _adjustDialog() {
            let a =
                    this._element.scrollHeight >
                    document.documentElement.clientHeight,
                d = at(),
                b = d > 0
            ;((!b && a && !c()) || (b && !a && c())) &&
                (this._element.style.paddingLeft = d + 'px'),
                ((b && !a && !c()) || (!b && a && c())) &&
                    (this._element.style.paddingRight = d + 'px')
        }
        _resetAdjustments() {
            ;(this._element.style.paddingLeft = ''),
                (this._element.style.paddingRight = '')
        }
        static jQueryInterface(a, b) {
            return this.each(function () {
                let c =
                    j.getInstance(this) ||
                    new j(this, 'object' == typeof a ? a : {})
                if ('string' == typeof a) {
                    if (void 0 === c[a])
                        throw new TypeError(`No method named "${a}"`)
                    c[a](b)
                }
            })
        }
    }
    $.on(
        document,
        'click.bs.modal.data-api',
        '[data-bs-toggle="modal"]',
        function (b) {
            let a = v(this)
            ;['A', 'AREA'].includes(this.tagName) && b.preventDefault(),
                $.one(a, 'show.bs.modal', b => {
                    b.defaultPrevented ||
                        $.one(a, 'hidden.bs.modal', () => {
                            C(this) && this.focus()
                        })
                }),
                (j.getInstance(a) || new j(a)).toggle(this)
        },
    ),
        a(j)
    let aE = { backdrop: !0, keyboard: !0, scroll: !1 },
        aF = { backdrop: 'boolean', keyboard: 'boolean', scroll: 'boolean' }
    class k extends b {
        constructor(a, b) {
            super(a),
                (this._config = this._getConfig(b)),
                (this._isShown = !1),
                (this._backdrop = this._initializeBackDrop()),
                this._addEventListeners()
        }
        static get NAME() {
            return 'offcanvas'
        }
        static get Default() {
            return aE
        }
        toggle(a) {
            return this._isShown ? this.hide() : this.show(a)
        }
        show(a) {
            this._isShown ||
                $.trigger(this._element, 'show.bs.offcanvas', {
                    relatedTarget: a,
                }).defaultPrevented ||
                ((this._isShown = !0),
                (this._element.style.visibility = 'visible'),
                this._backdrop.show(),
                this._config.scroll ||
                    (au(), this._enforceFocusOnElement(this._element)),
                this._element.removeAttribute('aria-hidden'),
                this._element.setAttribute('aria-modal', !0),
                this._element.setAttribute('role', 'dialog'),
                this._element.classList.add('show'),
                this._queueCallback(
                    () => {
                        $.trigger(this._element, 'shown.bs.offcanvas', {
                            relatedTarget: a,
                        })
                    },
                    this._element,
                    !0,
                ))
        }
        hide() {
            this._isShown &&
                ($.trigger(this._element, 'hide.bs.offcanvas')
                    .defaultPrevented ||
                    ($.off(document, 'focusin.bs.offcanvas'),
                    this._element.blur(),
                    (this._isShown = !1),
                    this._element.classList.remove('show'),
                    this._backdrop.hide(),
                    this._queueCallback(
                        () => {
                            this._element.setAttribute('aria-hidden', !0),
                                this._element.removeAttribute('aria-modal'),
                                this._element.removeAttribute('role'),
                                (this._element.style.visibility = 'hidden'),
                                this._config.scroll || ax(),
                                $.trigger(this._element, 'hidden.bs.offcanvas')
                        },
                        this._element,
                        !0,
                    )))
        }
        dispose() {
            this._backdrop.dispose(),
                super.dispose(),
                $.off(document, 'focusin.bs.offcanvas')
        }
        _getConfig(a) {
            return (
                B(
                    'offcanvas',
                    (a = {
                        ...aE,
                        ...ab.getDataAttributes(this._element),
                        ...('object' == typeof a ? a : {}),
                    }),
                    aF,
                ),
                a
            )
        }
        _initializeBackDrop() {
            return new aB({
                isVisible: this._config.backdrop,
                isAnimated: !0,
                rootElement: this._element.parentNode,
                clickCallback: () => this.hide(),
            })
        }
        _enforceFocusOnElement(a) {
            $.off(document, 'focusin.bs.offcanvas'),
                $.on(document, 'focusin.bs.offcanvas', b => {
                    document === b.target ||
                        a === b.target ||
                        a.contains(b.target) ||
                        a.focus()
                }),
                a.focus()
        }
        _addEventListeners() {
            $.on(
                this._element,
                'click.dismiss.bs.offcanvas',
                '[data-bs-dismiss="offcanvas"]',
                () => this.hide(),
            ),
                $.on(this._element, 'keydown.dismiss.bs.offcanvas', a => {
                    this._config.keyboard && 'Escape' === a.key && this.hide()
                })
        }
        static jQueryInterface(a) {
            return this.each(function () {
                let b =
                    J.get(this, 'bs.offcanvas') ||
                    new k(this, 'object' == typeof a ? a : {})
                if ('string' == typeof a) {
                    if (
                        void 0 === b[a] ||
                        a.startsWith('_') ||
                        'constructor' === a
                    )
                        throw new TypeError(`No method named "${a}"`)
                    b[a](this)
                }
            })
        }
    }
    $.on(
        document,
        'click.bs.offcanvas.data-api',
        '[data-bs-toggle="offcanvas"]',
        function (c) {
            let a = v(this)
            if (
                (['A', 'AREA'].includes(this.tagName) && c.preventDefault(),
                D(this))
            )
                return
            $.one(a, 'hidden.bs.offcanvas', () => {
                C(this) && this.focus()
            })
            let b = r.findOne('.offcanvas.show')
            b && b !== a && k.getInstance(b).hide(),
                (J.get(a, 'bs.offcanvas') || new k(a)).toggle(this)
        },
    ),
        $.on(window, 'load.bs.offcanvas.data-api', () => {
            r.find('.offcanvas.show').forEach(a =>
                (J.get(a, 'bs.offcanvas') || new k(a)).show(),
            )
        }),
        a(k)
    let aG = new Set([
            'background',
            'cite',
            'href',
            'itemtype',
            'longdesc',
            'poster',
            'src',
            'xlink:href',
        ]),
        aH = /^(?:(?:https?|mailto|ftp|tel|file):|[^#&/:?]*(?:[#/?]|$))/i,
        aI = /^data:(?:image\/(?:bmp|gif|jpeg|jpg|png|tiff|webp)|video\/(?:mpeg|mp4|ogg|webm)|audio\/(?:mp3|oga|ogg|opus));base64,[\d+/a-z]+=*$/i,
        aJ = (a, d) => {
            let b = a.nodeName.toLowerCase()
            if (d.includes(b))
                return (
                    !aG.has(b) ||
                    Boolean(aH.test(a.nodeValue) || aI.test(a.nodeValue))
                )
            let e = d.filter(a => a instanceof RegExp)
            for (let c = 0, f = e.length; c < f; c++)
                if (e[c].test(b)) return !0
            return !1
        }
    function aK(a, c, d) {
        if (!a.length) return a
        if (d && 'function' == typeof d) return d(a)
        let f = new window.DOMParser().parseFromString(a, 'text/html'),
            i = Object.keys(c),
            g = [].concat(...f.body.querySelectorAll('*'))
        for (let e = 0, j = g.length; e < j; e++) {
            let b = g[e],
                h = b.nodeName.toLowerCase()
            if (!i.includes(h)) {
                b.parentNode.removeChild(b)
                continue
            }
            let k = [].concat(...b.attributes),
                l = [].concat(c['*'] || [], c[h] || [])
            k.forEach(a => {
                aJ(a, l) || b.removeAttribute(a.nodeName)
            })
        }
        return f.body.innerHTML
    }
    let aL = new RegExp('(^|\\s)bs-tooltip\\S+', 'g'),
        aM = new Set(['sanitize', 'allowList', 'sanitizeFn']),
        aN = {
            animation: 'boolean',
            template: 'string',
            title: '(string|element|function)',
            trigger: 'string',
            delay: '(number|object)',
            html: 'boolean',
            selector: '(string|boolean)',
            placement: '(string|function)',
            offset: '(array|string|function)',
            container: '(string|element|boolean)',
            fallbackPlacements: 'array',
            boundary: '(string|element)',
            customClass: '(string|function)',
            sanitize: 'boolean',
            sanitizeFn: '(null|function)',
            allowList: 'object',
            popperConfig: '(null|object|function)',
        },
        aO = {
            AUTO: 'auto',
            TOP: 'top',
            RIGHT: c() ? 'left' : 'right',
            BOTTOM: 'bottom',
            LEFT: c() ? 'right' : 'left',
        },
        aP = {
            animation: !0,
            template:
                '<div class="tooltip" role="tooltip"><div class="tooltip-arrow"></div><div class="tooltip-inner"></div></div>',
            trigger: 'hover focus',
            title: '',
            delay: 0,
            html: !1,
            selector: !1,
            placement: 'top',
            offset: [0, 0],
            container: !1,
            fallbackPlacements: ['top', 'right', 'bottom', 'left'],
            boundary: 'clippingParents',
            customClass: '',
            sanitize: !0,
            sanitizeFn: null,
            allowList: {
                '*': ['class', 'dir', 'id', 'lang', 'role', /^aria-[\w-]*$/i],
                a: ['target', 'href', 'title', 'rel'],
                area: [],
                b: [],
                br: [],
                col: [],
                code: [],
                div: [],
                em: [],
                hr: [],
                h1: [],
                h2: [],
                h3: [],
                h4: [],
                h5: [],
                h6: [],
                i: [],
                img: ['src', 'srcset', 'alt', 'title', 'width', 'height'],
                li: [],
                ol: [],
                p: [],
                pre: [],
                s: [],
                small: [],
                span: [],
                sub: [],
                sup: [],
                strong: [],
                u: [],
                ul: [],
            },
            popperConfig: null,
        },
        aQ = {
            HIDE: 'hide.bs.tooltip',
            HIDDEN: 'hidden.bs.tooltip',
            SHOW: 'show.bs.tooltip',
            SHOWN: 'shown.bs.tooltip',
            INSERTED: 'inserted.bs.tooltip',
            CLICK: 'click.bs.tooltip',
            FOCUSIN: 'focusin.bs.tooltip',
            FOCUSOUT: 'focusout.bs.tooltip',
            MOUSEENTER: 'mouseenter.bs.tooltip',
            MOUSELEAVE: 'mouseleave.bs.tooltip',
        }
    class e extends b {
        constructor(a, b) {
            if (void 0 === q)
                throw new TypeError(
                    "Bootstrap's tooltips require Popper (https://popper.js.org)",
                )
            super(a),
                (this._isEnabled = !0),
                (this._timeout = 0),
                (this._hoverState = ''),
                (this._activeTrigger = {}),
                (this._popper = null),
                (this._config = this._getConfig(b)),
                (this.tip = null),
                this._setListeners()
        }
        static get Default() {
            return aP
        }
        static get NAME() {
            return 'tooltip'
        }
        static get Event() {
            return aQ
        }
        static get DefaultType() {
            return aN
        }
        enable() {
            this._isEnabled = !0
        }
        disable() {
            this._isEnabled = !1
        }
        toggleEnabled() {
            this._isEnabled = !this._isEnabled
        }
        toggle(b) {
            if (this._isEnabled) {
                if (b) {
                    let a = this._initializeOnDelegatedTarget(b)
                    ;(a._activeTrigger.click = !a._activeTrigger.click),
                        a._isWithActiveTrigger()
                            ? a._enter(null, a)
                            : a._leave(null, a)
                } else {
                    if (this.getTipElement().classList.contains('show'))
                        return void this._leave(null, this)
                    this._enter(null, this)
                }
            }
        }
        dispose() {
            clearTimeout(this._timeout),
                $.off(
                    this._element.closest('.modal'),
                    'hide.bs.modal',
                    this._hideModalHandler,
                ),
                this.tip &&
                    this.tip.parentNode &&
                    this.tip.parentNode.removeChild(this.tip),
                this._popper && this._popper.destroy(),
                super.dispose()
        }
        show() {
            if ('none' === this._element.style.display)
                throw new Error('Please use show on visible elements')
            if (!this.isWithContent() || !this._isEnabled) return
            let f = $.trigger(this._element, this.constructor.Event.SHOW),
                b = E(this._element),
                g =
                    null === b
                        ? this._element.ownerDocument.documentElement.contains(
                              this._element,
                          )
                        : b.contains(this._element)
            if (f.defaultPrevented || !g) return
            let a = this.getTipElement(),
                c = s(this.constructor.NAME)
            a.setAttribute('id', c),
                this._element.setAttribute('aria-describedby', c),
                this.setContent(),
                this._config.animation && a.classList.add('fade')
            let h =
                    'function' == typeof this._config.placement
                        ? this._config.placement.call(this, a, this._element)
                        : this._config.placement,
                d = this._getAttachment(h)
            this._addAttachmentClass(d)
            let { container: i } = this._config
            J.set(a, this.constructor.DATA_KEY, this),
                this._element.ownerDocument.documentElement.contains(
                    this.tip,
                ) ||
                    (i.appendChild(a),
                    $.trigger(this._element, this.constructor.Event.INSERTED)),
                this._popper
                    ? this._popper.update()
                    : (this._popper = q.createPopper(
                          this._element,
                          a,
                          this._getPopperConfig(d),
                      )),
                a.classList.add('show')
            let e =
                'function' == typeof this._config.customClass
                    ? this._config.customClass()
                    : this._config.customClass
            e && a.classList.add(...e.split(' ')),
                'ontouchstart' in document.documentElement &&
                    [].concat(...document.body.children).forEach(a => {
                        $.on(a, 'mouseover', _)
                    })
            let j = this.tip.classList.contains('fade')
            this._queueCallback(
                () => {
                    let a = this._hoverState
                    ;(this._hoverState = null),
                        $.trigger(this._element, this.constructor.Event.SHOWN),
                        'out' === a && this._leave(null, this)
                },
                this.tip,
                j,
            )
        }
        hide() {
            if (!this._popper) return
            let a = this.getTipElement()
            if (
                $.trigger(this._element, this.constructor.Event.HIDE)
                    .defaultPrevented
            )
                return
            a.classList.remove('show'),
                'ontouchstart' in document.documentElement &&
                    []
                        .concat(...document.body.children)
                        .forEach(a => $.off(a, 'mouseover', _)),
                (this._activeTrigger.click = !1),
                (this._activeTrigger.focus = !1),
                (this._activeTrigger.hover = !1)
            let b = this.tip.classList.contains('fade')
            this._queueCallback(
                () => {
                    this._isWithActiveTrigger() ||
                        ('show' !== this._hoverState &&
                            a.parentNode &&
                            a.parentNode.removeChild(a),
                        this._cleanTipClass(),
                        this._element.removeAttribute('aria-describedby'),
                        $.trigger(this._element, this.constructor.Event.HIDDEN),
                        this._popper &&
                            (this._popper.destroy(), (this._popper = null)))
                },
                this.tip,
                b,
            ),
                (this._hoverState = '')
        }
        update() {
            null !== this._popper && this._popper.update()
        }
        isWithContent() {
            return Boolean(this.getTitle())
        }
        getTipElement() {
            if (this.tip) return this.tip
            let a = document.createElement('div')
            return (
                (a.innerHTML = this._config.template),
                (this.tip = a.children[0]),
                this.tip
            )
        }
        setContent() {
            let a = this.getTipElement()
            this.setElementContent(
                r.findOne('.tooltip-inner', a),
                this.getTitle(),
            ),
                a.classList.remove('fade', 'show')
        }
        setElementContent(b, a) {
            if (null !== b)
                return y(a)
                    ? ((a = z(a)),
                      void (this._config.html
                          ? a.parentNode !== b &&
                            ((b.innerHTML = ''), b.appendChild(a))
                          : (b.textContent = a.textContent)))
                    : void (this._config.html
                          ? (this._config.sanitize &&
                                (a = aK(
                                    a,
                                    this._config.allowList,
                                    this._config.sanitizeFn,
                                )),
                            (b.innerHTML = a))
                          : (b.textContent = a))
        }
        getTitle() {
            let a = this._element.getAttribute('data-bs-original-title')
            return (
                a ||
                    (a =
                        'function' == typeof this._config.title
                            ? this._config.title.call(this._element)
                            : this._config.title),
                a
            )
        }
        updateAttachment(a) {
            return 'right' === a ? 'end' : 'left' === a ? 'start' : a
        }
        _initializeOnDelegatedTarget(b, a) {
            let c = this.constructor.DATA_KEY
            return (
                (a = a || J.get(b.delegateTarget, c)) ||
                    ((a = new this.constructor(
                        b.delegateTarget,
                        this._getDelegateConfig(),
                    )),
                    J.set(b.delegateTarget, c, a)),
                a
            )
        }
        _getOffset() {
            let { offset: a } = this._config
            return 'string' == typeof a
                ? a.split(',').map(a => Number.parseInt(a, 10))
                : 'function' == typeof a
                ? b => a(b, this._element)
                : a
        }
        _getPopperConfig(b) {
            let a = {
                placement: b,
                modifiers: [
                    {
                        name: 'flip',
                        options: {
                            fallbackPlacements: this._config.fallbackPlacements,
                        },
                    },
                    { name: 'offset', options: { offset: this._getOffset() } },
                    {
                        name: 'preventOverflow',
                        options: { boundary: this._config.boundary },
                    },
                    {
                        name: 'arrow',
                        options: { element: `.${this.constructor.NAME}-arrow` },
                    },
                    {
                        name: 'onChange',
                        enabled: !0,
                        phase: 'afterWrite',
                        fn: a => this._handlePopperPlacementChange(a),
                    },
                ],
                onFirstUpdate: a => {
                    a.options.placement !== a.placement &&
                        this._handlePopperPlacementChange(a)
                },
            }
            return {
                ...a,
                ...('function' == typeof this._config.popperConfig
                    ? this._config.popperConfig(a)
                    : this._config.popperConfig),
            }
        }
        _addAttachmentClass(a) {
            this.getTipElement().classList.add(
                'bs-tooltip-' + this.updateAttachment(a),
            )
        }
        _getAttachment(a) {
            return aO[a.toUpperCase()]
        }
        _setListeners() {
            this._config.trigger.split(' ').forEach(a => {
                if ('click' === a)
                    $.on(
                        this._element,
                        this.constructor.Event.CLICK,
                        this._config.selector,
                        a => this.toggle(a),
                    )
                else if ('manual' !== a) {
                    let b =
                            'hover' === a
                                ? this.constructor.Event.MOUSEENTER
                                : this.constructor.Event.FOCUSIN,
                        c =
                            'hover' === a
                                ? this.constructor.Event.MOUSELEAVE
                                : this.constructor.Event.FOCUSOUT
                    $.on(this._element, b, this._config.selector, a =>
                        this._enter(a),
                    ),
                        $.on(this._element, c, this._config.selector, a =>
                            this._leave(a),
                        )
                }
            }),
                (this._hideModalHandler = () => {
                    this._element && this.hide()
                }),
                $.on(
                    this._element.closest('.modal'),
                    'hide.bs.modal',
                    this._hideModalHandler,
                ),
                this._config.selector
                    ? (this._config = {
                          ...this._config,
                          trigger: 'manual',
                          selector: '',
                      })
                    : this._fixTitle()
        }
        _fixTitle() {
            let a = this._element.getAttribute('title'),
                b = typeof this._element.getAttribute('data-bs-original-title')
            ;(a || 'string' !== b) &&
                (this._element.setAttribute('data-bs-original-title', a || ''),
                !a ||
                    this._element.getAttribute('aria-label') ||
                    this._element.textContent ||
                    this._element.setAttribute('aria-label', a),
                this._element.setAttribute('title', ''))
        }
        _enter(b, a) {
            ;(a = this._initializeOnDelegatedTarget(b, a)),
                b &&
                    (a._activeTrigger[
                        'focusin' === b.type ? 'focus' : 'hover'
                    ] = !0),
                a.getTipElement().classList.contains('show') ||
                'show' === a._hoverState
                    ? (a._hoverState = 'show')
                    : (clearTimeout(a._timeout),
                      (a._hoverState = 'show'),
                      a._config.delay && a._config.delay.show
                          ? (a._timeout = setTimeout(() => {
                                'show' === a._hoverState && a.show()
                            }, a._config.delay.show))
                          : a.show())
        }
        _leave(b, a) {
            ;(a = this._initializeOnDelegatedTarget(b, a)),
                b &&
                    (a._activeTrigger[
                        'focusout' === b.type ? 'focus' : 'hover'
                    ] = a._element.contains(b.relatedTarget)),
                a._isWithActiveTrigger() ||
                    (clearTimeout(a._timeout),
                    (a._hoverState = 'out'),
                    a._config.delay && a._config.delay.hide
                        ? (a._timeout = setTimeout(() => {
                              'out' === a._hoverState && a.hide()
                          }, a._config.delay.hide))
                        : a.hide())
        }
        _isWithActiveTrigger() {
            for (let a in this._activeTrigger)
                if (this._activeTrigger[a]) return !0
            return !1
        }
        _getConfig(a) {
            let b = ab.getDataAttributes(this._element)
            return (
                Object.keys(b).forEach(a => {
                    aM.has(a) && delete b[a]
                }),
                ((a = {
                    ...this.constructor.Default,
                    ...b,
                    ...('object' == typeof a && a ? a : {}),
                }).container =
                    !1 === a.container ? document.body : z(a.container)),
                'number' == typeof a.delay &&
                    (a.delay = { show: a.delay, hide: a.delay }),
                'number' == typeof a.title && (a.title = a.title.toString()),
                'number' == typeof a.content &&
                    (a.content = a.content.toString()),
                B('tooltip', a, this.constructor.DefaultType),
                a.sanitize &&
                    (a.template = aK(a.template, a.allowList, a.sanitizeFn)),
                a
            )
        }
        _getDelegateConfig() {
            let b = {}
            if (this._config)
                for (let a in this._config)
                    this.constructor.Default[a] !== this._config[a] &&
                        (b[a] = this._config[a])
            return b
        }
        _cleanTipClass() {
            let b = this.getTipElement(),
                a = b.getAttribute('class').match(aL)
            null !== a &&
                a.length > 0 &&
                a.map(a => a.trim()).forEach(a => b.classList.remove(a))
        }
        _handlePopperPlacementChange(b) {
            let { state: a } = b
            a &&
                ((this.tip = a.elements.popper),
                this._cleanTipClass(),
                this._addAttachmentClass(this._getAttachment(a.placement)))
        }
        static jQueryInterface(a) {
            return this.each(function () {
                let b = J.get(this, 'bs.tooltip')
                if (
                    (b || !/dispose|hide/.test(a)) &&
                    (b || (b = new e(this, 'object' == typeof a && a)),
                    'string' == typeof a)
                ) {
                    if (void 0 === b[a])
                        throw new TypeError(`No method named "${a}"`)
                    b[a]()
                }
            })
        }
    }
    a(e)
    let aR = new RegExp('(^|\\s)bs-popover\\S+', 'g'),
        aS = {
            ...e.Default,
            placement: 'right',
            offset: [0, 8],
            trigger: 'click',
            content: '',
            template:
                '<div class="popover" role="tooltip"><div class="popover-arrow"></div><h3 class="popover-header"></h3><div class="popover-body"></div></div>',
        },
        aT = { ...e.DefaultType, content: '(string|element|function)' },
        aU = {
            HIDE: 'hide.bs.popover',
            HIDDEN: 'hidden.bs.popover',
            SHOW: 'show.bs.popover',
            SHOWN: 'shown.bs.popover',
            INSERTED: 'inserted.bs.popover',
            CLICK: 'click.bs.popover',
            FOCUSIN: 'focusin.bs.popover',
            FOCUSOUT: 'focusout.bs.popover',
            MOUSEENTER: 'mouseenter.bs.popover',
            MOUSELEAVE: 'mouseleave.bs.popover',
        }
    class l extends e {
        static get Default() {
            return aS
        }
        static get NAME() {
            return 'popover'
        }
        static get Event() {
            return aU
        }
        static get DefaultType() {
            return aT
        }
        isWithContent() {
            return this.getTitle() || this._getContent()
        }
        setContent() {
            let b = this.getTipElement()
            this.setElementContent(
                r.findOne('.popover-header', b),
                this.getTitle(),
            )
            let a = this._getContent()
            'function' == typeof a && (a = a.call(this._element)),
                this.setElementContent(r.findOne('.popover-body', b), a),
                b.classList.remove('fade', 'show')
        }
        _addAttachmentClass(a) {
            this.getTipElement().classList.add(
                'bs-popover-' + this.updateAttachment(a),
            )
        }
        _getContent() {
            return (
                this._element.getAttribute('data-bs-content') ||
                this._config.content
            )
        }
        _cleanTipClass() {
            let b = this.getTipElement(),
                a = b.getAttribute('class').match(aR)
            null !== a &&
                a.length > 0 &&
                a.map(a => a.trim()).forEach(a => b.classList.remove(a))
        }
        static jQueryInterface(a) {
            return this.each(function () {
                let b = J.get(this, 'bs.popover')
                if (
                    (b || !/dispose|hide/.test(a)) &&
                    (b ||
                        ((b = new l(this, 'object' == typeof a ? a : null)),
                        J.set(this, 'bs.popover', b)),
                    'string' == typeof a)
                ) {
                    if (void 0 === b[a])
                        throw new TypeError(`No method named "${a}"`)
                    b[a]()
                }
            })
        }
    }
    a(l)
    let aV = { offset: 10, method: 'auto', target: '' },
        aW = { offset: 'number', method: 'string', target: '(string|element)' }
    class m extends b {
        constructor(a, b) {
            super(a),
                (this._scrollElement =
                    'BODY' === this._element.tagName ? window : this._element),
                (this._config = this._getConfig(b)),
                (this._selector = `${this._config.target} .nav-link, ${this._config.target} .list-group-item, ${this._config.target} .dropdown-item`),
                (this._offsets = []),
                (this._targets = []),
                (this._activeTarget = null),
                (this._scrollHeight = 0),
                $.on(this._scrollElement, 'scroll.bs.scrollspy', () =>
                    this._process(),
                ),
                this.refresh(),
                this._process()
        }
        static get Default() {
            return aV
        }
        static get NAME() {
            return 'scrollspy'
        }
        refresh() {
            let a =
                    this._scrollElement === this._scrollElement.window
                        ? 'offset'
                        : 'position',
                b = 'auto' === this._config.method ? a : this._config.method,
                c = 'position' === b ? this._getScrollTop() : 0
            ;(this._offsets = []),
                (this._targets = []),
                (this._scrollHeight = this._getScrollHeight()),
                r
                    .find(this._selector)
                    .map(f => {
                        let a = u(f),
                            d = a ? r.findOne(a) : null
                        if (d) {
                            let e = d.getBoundingClientRect()
                            if (e.width || e.height)
                                return [ab[b](d).top + c, a]
                        }
                        return null
                    })
                    .filter(a => a)
                    .sort((a, b) => a[0] - b[0])
                    .forEach(a => {
                        this._offsets.push(a[0]), this._targets.push(a[1])
                    })
        }
        dispose() {
            $.off(this._scrollElement, '.bs.scrollspy'), super.dispose()
        }
        _getConfig(a) {
            if (
                'string' !=
                    typeof (a = {
                        ...aV,
                        ...ab.getDataAttributes(this._element),
                        ...('object' == typeof a && a ? a : {}),
                    }).target &&
                y(a.target)
            ) {
                let { id: b } = a.target
                b || ((b = s('scrollspy')), (a.target.id = b)),
                    (a.target = '#' + b)
            }
            return B('scrollspy', a, aW), a
        }
        _getScrollTop() {
            return this._scrollElement === window
                ? this._scrollElement.pageYOffset
                : this._scrollElement.scrollTop
        }
        _getScrollHeight() {
            return (
                this._scrollElement.scrollHeight ||
                Math.max(
                    document.body.scrollHeight,
                    document.documentElement.scrollHeight,
                )
            )
        }
        _getOffsetHeight() {
            return this._scrollElement === window
                ? window.innerHeight
                : this._scrollElement.getBoundingClientRect().height
        }
        _process() {
            let b = this._getScrollTop() + this._config.offset,
                c = this._getScrollHeight(),
                e = this._config.offset + c - this._getOffsetHeight()
            if ((this._scrollHeight !== c && this.refresh(), b >= e)) {
                let d = this._targets[this._targets.length - 1]
                this._activeTarget !== d && this._activate(d)
            } else {
                if (
                    this._activeTarget &&
                    b < this._offsets[0] &&
                    this._offsets[0] > 0
                )
                    return (this._activeTarget = null), void this._clear()
                for (let a = this._offsets.length; a--; )
                    this._activeTarget !== this._targets[a] &&
                        b >= this._offsets[a] &&
                        (void 0 === this._offsets[a + 1] ||
                            b < this._offsets[a + 1]) &&
                        this._activate(this._targets[a])
            }
        }
        _activate(b) {
            ;(this._activeTarget = b), this._clear()
            let c = this._selector
                    .split(',')
                    .map(a => `${a}[data-bs-target="${b}"],${a}[href="${b}"]`),
                a = r.findOne(c.join(','))
            a.classList.contains('dropdown-item')
                ? (r
                      .findOne('.dropdown-toggle', a.closest('.dropdown'))
                      .classList.add('active'),
                  a.classList.add('active'))
                : (a.classList.add('active'),
                  r.parents(a, '.nav, .list-group').forEach(a => {
                      r
                          .prev(a, '.nav-link, .list-group-item')
                          .forEach(a => a.classList.add('active')),
                          r.prev(a, '.nav-item').forEach(a => {
                              r.children(a, '.nav-link').forEach(a =>
                                  a.classList.add('active'),
                              )
                          })
                  })),
                $.trigger(this._scrollElement, 'activate.bs.scrollspy', {
                    relatedTarget: b,
                })
        }
        _clear() {
            r.find(this._selector)
                .filter(a => a.classList.contains('active'))
                .forEach(a => a.classList.remove('active'))
        }
        static jQueryInterface(a) {
            return this.each(function () {
                let b =
                    m.getInstance(this) ||
                    new m(this, 'object' == typeof a ? a : {})
                if ('string' == typeof a) {
                    if (void 0 === b[a])
                        throw new TypeError(`No method named "${a}"`)
                    b[a]()
                }
            })
        }
    }
    $.on(window, 'load.bs.scrollspy.data-api', () => {
        r.find('[data-bs-spy="scroll"]').forEach(a => new m(a))
    }),
        a(m)
    class n extends b {
        static get NAME() {
            return 'tab'
        }
        show() {
            if (
                this._element.parentNode &&
                this._element.parentNode.nodeType === Node.ELEMENT_NODE &&
                this._element.classList.contains('active')
            )
                return
            let a,
                c = v(this._element),
                b = this._element.closest('.nav, .list-group')
            if (b) {
                let f =
                    'UL' === b.nodeName || 'OL' === b.nodeName
                        ? ':scope > li > .active'
                        : '.active'
                a = (a = r.find(f, b))[a.length - 1]
            }
            let d = a
                ? $.trigger(a, 'hide.bs.tab', { relatedTarget: this._element })
                : null
            if (
                $.trigger(this._element, 'show.bs.tab', { relatedTarget: a })
                    .defaultPrevented ||
                (null !== d && d.defaultPrevented)
            )
                return
            this._activate(this._element, b)
            let e = () => {
                $.trigger(a, 'hidden.bs.tab', { relatedTarget: this._element }),
                    $.trigger(this._element, 'shown.bs.tab', {
                        relatedTarget: a,
                    })
            }
            c ? this._activate(c, c.parentNode, e) : e()
        }
        _activate(d, a, e) {
            let b = (a && ('UL' === a.nodeName || 'OL' === a.nodeName)
                    ? r.find(':scope > li > .active', a)
                    : r.children(a, '.active'))[0],
                f = e && b && b.classList.contains('fade'),
                c = () => this._transitionComplete(d, b, e)
            b && f
                ? (b.classList.remove('show'), this._queueCallback(c, d, !0))
                : c()
        }
        _transitionComplete(a, c, d) {
            if (c) {
                c.classList.remove('active')
                let e = r.findOne(
                    ':scope > .dropdown-menu .active',
                    c.parentNode,
                )
                e && e.classList.remove('active'),
                    'tab' === c.getAttribute('role') &&
                        c.setAttribute('aria-selected', !1)
            }
            a.classList.add('active'),
                'tab' === a.getAttribute('role') &&
                    a.setAttribute('aria-selected', !0),
                F(a),
                a.classList.contains('fade') && a.classList.add('show')
            let b = a.parentNode
            if (
                (b && 'LI' === b.nodeName && (b = b.parentNode),
                b && b.classList.contains('dropdown-menu'))
            ) {
                let f = a.closest('.dropdown')
                f &&
                    r
                        .find('.dropdown-toggle', f)
                        .forEach(a => a.classList.add('active')),
                    a.setAttribute('aria-expanded', !0)
            }
            d && d()
        }
        static jQueryInterface(a) {
            return this.each(function () {
                let b = J.get(this, 'bs.tab') || new n(this)
                if ('string' == typeof a) {
                    if (void 0 === b[a])
                        throw new TypeError(`No method named "${a}"`)
                    b[a]()
                }
            })
        }
    }
    $.on(
        document,
        'click.bs.tab.data-api',
        '[data-bs-toggle="tab"], [data-bs-toggle="pill"], [data-bs-toggle="list"]',
        function (a) {
            ;['A', 'AREA'].includes(this.tagName) && a.preventDefault(),
                D(this) || (J.get(this, 'bs.tab') || new n(this)).show()
        },
    ),
        a(n)
    let aX = { animation: 'boolean', autohide: 'boolean', delay: 'number' },
        aY = { animation: !0, autohide: !0, delay: 5e3 }
    class o extends b {
        constructor(a, b) {
            super(a),
                (this._config = this._getConfig(b)),
                (this._timeout = null),
                (this._hasMouseInteraction = !1),
                (this._hasKeyboardInteraction = !1),
                this._setListeners()
        }
        static get DefaultType() {
            return aX
        }
        static get Default() {
            return aY
        }
        static get NAME() {
            return 'toast'
        }
        show() {
            $.trigger(this._element, 'show.bs.toast').defaultPrevented ||
                (this._clearTimeout(),
                this._config.animation && this._element.classList.add('fade'),
                this._element.classList.remove('hide'),
                F(this._element),
                this._element.classList.add('showing'),
                this._queueCallback(
                    () => {
                        this._element.classList.remove('showing'),
                            this._element.classList.add('show'),
                            $.trigger(this._element, 'shown.bs.toast'),
                            this._maybeScheduleHide()
                    },
                    this._element,
                    this._config.animation,
                ))
        }
        hide() {
            this._element.classList.contains('show') &&
                ($.trigger(this._element, 'hide.bs.toast').defaultPrevented ||
                    (this._element.classList.remove('show'),
                    this._queueCallback(
                        () => {
                            this._element.classList.add('hide'),
                                $.trigger(this._element, 'hidden.bs.toast')
                        },
                        this._element,
                        this._config.animation,
                    )))
        }
        dispose() {
            this._clearTimeout(),
                this._element.classList.contains('show') &&
                    this._element.classList.remove('show'),
                super.dispose()
        }
        _getConfig(a) {
            return (
                B(
                    'toast',
                    (a = {
                        ...aY,
                        ...ab.getDataAttributes(this._element),
                        ...('object' == typeof a && a ? a : {}),
                    }),
                    this.constructor.DefaultType,
                ),
                a
            )
        }
        _maybeScheduleHide() {
            this._config.autohide &&
                (this._hasMouseInteraction ||
                    this._hasKeyboardInteraction ||
                    (this._timeout = setTimeout(() => {
                        this.hide()
                    }, this._config.delay)))
        }
        _onInteraction(b, a) {
            switch (b.type) {
                case 'mouseover':
                case 'mouseout':
                    this._hasMouseInteraction = a
                    break
                case 'focusin':
                case 'focusout':
                    this._hasKeyboardInteraction = a
            }
            if (a) return void this._clearTimeout()
            let c = b.relatedTarget
            this._element === c ||
                this._element.contains(c) ||
                this._maybeScheduleHide()
        }
        _setListeners() {
            $.on(
                this._element,
                'click.dismiss.bs.toast',
                '[data-bs-dismiss="toast"]',
                () => this.hide(),
            ),
                $.on(this._element, 'mouseover.bs.toast', a =>
                    this._onInteraction(a, !0),
                ),
                $.on(this._element, 'mouseout.bs.toast', a =>
                    this._onInteraction(a, !1),
                ),
                $.on(this._element, 'focusin.bs.toast', a =>
                    this._onInteraction(a, !0),
                ),
                $.on(this._element, 'focusout.bs.toast', a =>
                    this._onInteraction(a, !1),
                )
        }
        _clearTimeout() {
            clearTimeout(this._timeout), (this._timeout = null)
        }
        static jQueryInterface(a) {
            return this.each(function () {
                let b = J.get(this, 'bs.toast')
                if (
                    (b || (b = new o(this, 'object' == typeof a && a)),
                    'string' == typeof a)
                ) {
                    if (void 0 === b[a])
                        throw new TypeError(`No method named "${a}"`)
                    b[a](this)
                }
            })
        }
    }
    return (
        a(o),
        {
            Alert: f,
            Button: h,
            Carousel: g,
            Collapse: i,
            Dropdown: d,
            Modal: j,
            Offcanvas: k,
            Popover: l,
            ScrollSpy: m,
            Tab: n,
            Toast: o,
            Tooltip: e,
        }
    )
})
